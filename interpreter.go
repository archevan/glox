package main

import "reflect"

// Interpreter is an implementation of the Visitor interface to recursively
// walk the syntax tree generated by the parser. Tree-walk interpreter.
type Interpreter struct {
	// Lox return values are represented with an empty interface
	resultVal interface{}
}

// allow a given expression to call the correct Visit method for its type
func (in *Interpreter) evaluate(e Expr) interface{} {
	e.accept(in)
	return in.resultVal
}

// VisitBinaryExpr interprets any given binary expression
func (in *Interpreter) VisitBinaryExpr(b *BinaryExpr) {
	left := in.evaluate(b.left)
	right := in.evaluate(b.right)
	leftd := left.(float64)
	rightd := right.(float64)
	switch b.op.toktype {
	case Greater:
		in.resultVal = leftd > rightd
	case GreaterEqual:
		in.resultVal = leftd >= rightd
	case Less:
		in.resultVal = leftd < rightd
	case LessEqual:
		in.resultVal = leftd <= rightd
	case Minus:
		in.resultVal = leftd - rightd
	case Slash:
		in.resultVal = leftd / rightd
	case Star:
		in.resultVal = leftd * rightd
	case Plus:
		// plus can be applied to both numbers (doubles) and strings
		switch left.(type) {
		case float64:
			in.resultVal = leftd + rightd
		case string:
			in.resultVal = left.(string) + right.(string)
		}
	}
	// TODO: implement more binary operations
}

// isEqual checks whether two given values are equal.
// behavior is similar to Go's == but has support for nil values
func (in *Interpreter) isEqual(a, b interface{}) bool {
	if a == nil && b == nil {
		return true
	}
	if a == nil {
		return false
	}
	// same as Go's == for strings, booleans, and doubles (float64)
	return reflect.DeepEqual(a, b)
}

// VisitGrouping interprets any given Grouping expression
func (in *Interpreter) VisitGrouping(g *Grouping) {
	in.resultVal = in.evaluate(g.exp)
}

// VisitLiteral interprets any given Literal expression
func (in *Interpreter) VisitLiteral(l *Literal) {
	in.resultVal = l.val
}

// isTruthy determines whether a given value will evalulate to true
// nil and false both eval to false, everything else evaluates to true
func (in *Interpreter) isTruthy(val interface{}) bool {
	if val == nil {
		return false
	}
	switch v := val.(type) {
	case bool:
		return v
	}
	return true
}

// VisitUnary interprets any given Unary expression
func (in *Interpreter) VisitUnary(u *Unary) {
	right := in.evaluate(u.right)
	switch u.op.toktype {
	case Minus:
		in.resultVal = -right.(float64)
	case Bang:
		in.resultVal = !in.isTruthy(right)
	}
}
